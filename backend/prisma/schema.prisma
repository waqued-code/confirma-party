generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  parties   Party[]
}

enum MessageTemplateStatus {
  DRAFT           // Rascunho - ainda sendo editado
  PENDING_REVIEW  // Aguardando validação
  APPROVED        // Aprovado - pode enviar
  REJECTED        // Rejeitado - precisa ajustar
}

model Party {
  id                    String                @id @default(uuid())
  name                  String
  date                  DateTime
  contactDate           DateTime              // Data para começar a entrar em contato
  partyType             String                // Casamento, Aniversário, Corporativo, etc.
  observations          String?
  inviteMessage         String?               // Mensagem gerada pela IA
  messageTemplateStatus MessageTemplateStatus @default(DRAFT)
  validationErrors      String?               // Erros de validação em JSON
  firstInviteSentAt     DateTime?             // Data/hora do primeiro envio em massa
  plan                  PartyPlan             @default(GRATUITO)
  guestLimit            Int                   @default(15) // Limite de famílias
  userId                String
  user                  User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  guests                Guest[]
  payments              Payment[]
  followUps             FollowUp[]
  messageQueue          MessageQueue[]
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
}

enum GuestStatus {
  NAO_RESPONDEU
  CONFIRMOU_PRESENCA
  RECUSOU_CONVITE
  NECESSITA_CONVERSAR
}

enum ContactMethod {
  WHATSAPP
  LIGACAO
}

enum PartyPlan {
  GRATUITO      // 15 famílias
  FESTA         // 50 famílias - R$37
  CELEBRACAO    // 150 famílias - R$77
  PERSONALIZADO // Ilimitado - sob consulta
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

model Guest {
  id               String        @id @default(uuid())
  name             String
  phone            String
  contactMethod    ContactMethod @default(WHATSAPP)
  status           GuestStatus   @default(NAO_RESPONDEU)
  lastContactAt    DateTime?
  firstContactAt   DateTime?     // Data do primeiro contato
  followUp1SentAt  DateTime?     // Data do envio do follow-up 1
  followUp2SentAt  DateTime?     // Data do envio do follow-up 2
  sendError        String?       // Último erro de envio
  notes            String?       // Observações da conversa
  partyId          String
  party            Party         @relation(fields: [partyId], references: [id], onDelete: Cascade)
  messages         Message[]
  messageQueue     MessageQueue[]
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
}

model Message {
  id        String   @id @default(uuid())
  content   String
  isFromAI  Boolean  @default(false)
  guestId   String
  guest     Guest    @relation(fields: [guestId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

model Payment {
  id              String        @id @default(uuid())
  amount          Int           // Valor em centavos (3700 = R$37,00)
  status          PaymentStatus @default(PENDING)
  plan            PartyPlan     // Plano sendo comprado
  paymentMethod   String?       // pix, credit_card, etc
  externalId      String?       // ID da transação no gateway (Stripe, etc)
  partyId         String
  party           Party         @relation(fields: [partyId], references: [id], onDelete: Cascade)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

enum FollowUpScheduleType {
  SPECIFIC_DATE       // Data específica
  DAYS_BEFORE_PARTY   // X dias antes da festa
  DAYS_AFTER_INVITE   // X dias depois do primeiro convite
}

enum FollowUpStatus {
  PENDING   // Aguardando envio
  SENT      // Enviado
  FAILED    // Falhou
}

model FollowUp {
  id            String               @id @default(uuid())
  message       String               // Mensagem do follow-up
  scheduleType  FollowUpScheduleType // Tipo de agendamento
  scheduledDate DateTime?            // Data específica (quando scheduleType = SPECIFIC_DATE)
  daysOffset    Int?                 // Dias de offset (para DAYS_BEFORE_PARTY ou DAYS_AFTER_INVITE)
  status        FollowUpStatus       @default(PENDING)
  sentAt        DateTime?            // Data/hora do envio efetivo
  order         Int                  // 1 ou 2 (ordem do follow-up)
  partyId       String
  party         Party                @relation(fields: [partyId], references: [id], onDelete: Cascade)
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  @@unique([partyId, order]) // Apenas um follow-up por ordem por festa
}

enum MessageQueueStatus {
  SCHEDULED   // Agendado para envio
  SENDING     // Enviando
  SENT        // Enviado com sucesso
  FAILED      // Falhou no envio
  CANCELLED   // Cancelado
}

enum MessageQueueType {
  INVITE      // Convite inicial
  FOLLOW_UP_1 // Follow-up 1
  FOLLOW_UP_2 // Follow-up 2
  CUSTOM      // Mensagem personalizada
}

model MessageQueue {
  id            String             @id @default(uuid())
  type          MessageQueueType   // Tipo da mensagem
  content       String             // Conteúdo da mensagem
  scheduledFor  DateTime           // Data/hora agendada para envio
  status        MessageQueueStatus @default(SCHEDULED)
  attempts      Int                @default(0) // Tentativas de envio
  lastError     String?            // Último erro
  sentAt        DateTime?          // Data/hora do envio efetivo
  guestId       String
  guest         Guest              @relation(fields: [guestId], references: [id], onDelete: Cascade)
  partyId       String
  party         Party              @relation(fields: [partyId], references: [id], onDelete: Cascade)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  @@index([status, scheduledFor]) // Index para buscar mensagens pendentes
}
